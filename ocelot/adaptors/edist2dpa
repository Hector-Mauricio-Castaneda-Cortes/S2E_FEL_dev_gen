def dpa2edist(out, dpa, num_part=1e5, smear=1, debug=1):
    '''
    reads GenesisParticlesDump() object
    returns GenesisElectronDist() object
    smear - whether to shuffle macroparticles smearing microbunching
    '''
    import random
    start_time = time.time()
    if debug > 0:
        print ('    transforming particle to distribution file')

    assert out('itdp') == True, '! steadystate Genesis simulation, dpa2dist() not implemented yet!'

    npart = int(out('npart'))
    # nslice=int(out('nslice'))
    nslice = int(out.nSlices * out('ishsty'))
    nbins = int(out('nbins'))
    xlamds = out('xlamds')
    zsep = int(out('zsep'))
    gen_I = out.I
    gen_t = out.t

    # if dpa==None:
    # dpa=out.filePath+'.dpa'
    # if dpa.__class__==str:
    # try:
    # dpa=read_dpa_file(dpa, nbins=nbins, npart=npart,debug=debug)
    # except IOError:
    # print ('      ERR: no such file "'+dpa+'"')
    # print ('      ERR: reading "'+out.filePath+'.dpa'+'"')
    # dpa=read_dpa_file(out.filePath+'.dpa', nbins=nbins, npart=npart,debug=debug)
    # if dpa.__class__!=GenesisParticles:
    # print('   could not read particle file')

    m = np.arange(nslice)
    m = np.tile(m, (nbins, npart / nbins, 1))
    m = np.rollaxis(m, 2, 0)
    # print('shape_m='+str(shape(m)))


    if smear:
        z = dpa.ph * xlamds / 2 / pi + m * xlamds * zsep + xlamds * zsep * (
        1 - np.random.random((nslice, nbins, int(npart / nbins))))
    else:
        z = dpa.ph * xlamds / 2 / pi + m * xlamds * zsep

    t = np.array(z / speed_of_light)

    t_scale = np.linspace(0, nslice * zsep * xlamds / speed_of_light * 1e15, nslice)

    pick_n = np.interp(t_scale, gen_t, gen_I)
    if debug > 1:
        print('sum pick_n=' + str(sum(pick_n)))
    if debug > 1:
        print('npart=' + str(npart))
    if debug > 1:
        print('num_part=' + str(num_part))
    pick_n = pick_n / sum(pick_n) * num_part
    if max(pick_n) > npart:
        pick_n = pick_n / max(pick_n) * npart
    pick_n = pick_n.astype(int)
    # ratio=ceil(num_part/np.sum(pick_n))
    ratio = 1

    t = np.reshape(t, (nslice, npart))
    e = np.reshape(dpa.e, (nslice, npart))
    x = np.reshape(dpa.x, (nslice, npart))
    y = np.reshape(dpa.y, (nslice, npart))
    px = np.reshape(dpa.px, (nslice, npart))
    py = np.reshape(dpa.py, (nslice, npart))

    edist = GenesisElectronDist()
    for i in np.arange(nslice):
        for ii in np.arange(int(ratio)):
            pick_i = random.sample(range(npart), pick_n[i])
            edist.t = append(edist.t, t[i, pick_i])
            edist.g = append(edist.g, e[i, pick_i])
            edist.x = append(edist.x, x[i, pick_i])
            edist.y = append(edist.y, y[i, pick_i])
            edist.xp = append(edist.xp, px[i, pick_i])
            edist.yp = append(edist.yp, py[i, pick_i])

    edist.t = edist.t * (-1) + max(edist.t)
    edist.xp /= edist.g
    edist.yp /= edist.g

    edist.x = np.flipud(edist.x)
    edist.y = np.flipud(edist.y)
    edist.xp = np.flipud(edist.xp)
    edist.yp = np.flipud(edist.yp)
    edist.t = np.flipud(edist.t)
    edist.g = np.flipud(edist.g)

    edist.part_charge = out.beam_charge / edist.len()
    # edist.charge=out.beam_charge
    edist.filePath = dpa.filePath + '.edist'
    # print 'max_y_out', np.amax(t_out)
    # print 'e_out', np.amax(e_out),np.amin(e_out)

    if debug > 0:
        print('      done in %.2f sec' % (time.time() - start_time))

    return edist


def write_dpa_file(dpa, filePath=None, debug=1):
    if debug > 0:
        print ('    writing particle file')
    start_time = time.time()

    if dpa.__class__ != GenesisParticlesDump:
        raise ValueError('wrong particles object: should be GenesisParticlesDump')

    if filePath == None:
        filePath = dpa.filePath

    nslice, nbins, npart = dpa.e.shape
    b = np.zeros((nslice, 6, nbins, npart))

    b[:, 0, :, :] = dpa.e
    b[:, 1, :, :] = dpa.ph
    b[:, 2, :, :] = dpa.x
    b[:, 3, :, :] = dpa.y
    b[:, 4, :, :] = dpa.px
    b[:, 5, :, :] = dpa.py
    b = b.flatten()
    b.tofile(filePath)

    if debug > 0:
        print('      done in %.2f sec' % (time.time() - start_time))